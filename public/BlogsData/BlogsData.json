[
  {
    "content":[
  "<h3>Webpack</h3>",
  "<p>目前主流的前端框架的脚手架都是基于webpack搭建的，其在官方网站上的定位是<code>static module bundler</code>，以一个入口文件作为整个项目的依赖入口（默认取&#39;./src/index.js&#39;），将所有与之相关联的js/css/font等资源当做模块(模块中可以引入和导出其他模块资源)，打包build成可以部署在服务器上供用户访问的静态资源。</p>",
  "<h4>全局webpack与局部webpack</h4>",
  "<p>不同的项目可能会依赖不同版本的webpack，比如新项目可能用到的webpack版本可能会比旧项目中用到的webpack版本要高，且每个项目中的packjson-lock文件中会锁定所需要的webpack版本。</p>",
  "<p>直接在项目代码中使用<code>webpack</code>指令，默认会去调用全局环境(-global)下通过npm安装的webpack，如果需要指定某一个项目的特定webpack版本，可以在命令行里使用:</p>",
  "<pre class='language-javascript'><code>npx webpack",
  "</code></pre>",
  "<p>进行打包。如果该项目指定了devDependencies中的webpack版本，则会使用局部的webpack版本。</p>",
  "<p>更通用的一种方式是在package.json文件的<code>scripts</code>选项中指定一个指令:</p>",
  "<pre class='language-javascript'><code class='language-json' lang='json'>{",
  "&quot;scripts&quot;:{",
  "&quot;build&quot;:&quot;webpack&quot;",
  "}",
  "}",
  "</code></pre>",
  "<p>此时的在命令行输入<code>npm run build</code>就会默认使用本地版本的webpack</p>",
  "<blockquote><p>补充:可以去node_modules下的bin文件中找webpack </p>",
  "</blockquote>",
  "<h4>webpack配置</h4>",
  "<blockquote><p>目前主流的前端框架的脚手架都是基于webpack搭建的，其在官方网站上的定位是<code>static module bundler</code>，以一个入口文件作为整个项目的依赖入口（默认取&#39;./src/index.js&#39;）</p>",
  "</blockquote>",
  "<p>为了能够在命令行里面指定webpack的某些配置，我们需要安装webpack-cli来帮助我们指定webpack的一些配置指令:</p>",
  "<pre class='language-javascript'><code class='language-json' lang='json'>{",
  "&quot;scripts&quot;:{",
  "&quot;build&quot;:&quot;webpack --entry ./src/index.js --output ...&quot;",
  "}",
  "}",
  "</code></pre>",
  "<p>然而有关webpack的配置有非常之多，不可能在脚本里一一列举出来，比较好的实践是在项目的根路径下创建一个名为<code>webpack.config.js</code>的文件供webpack默认读取:</p>",
  "<pre class='language-javascript'><code class='language-javascript' lang='javascript'>// 引入path模块做路径拼接",
  "import {resolve} from &#39;path&#39;",
  "",
  "module.exports = {",
  "entry:&#39;./src/index.js&#39;,",
  "output:{",
  "// 指定打包文件的出口时，path必须为绝对路径",
  "path:resolve(__dirname,&#39;./build&#39;),",
  "filename:&#39;myBundle.js&#39;",
  "}",
  "}",
  "</code></pre>",
  "<h3>webpack默认只认识javascript和模块化语法</h3>",
  "<p>在js模块之间使用es module/commonJs 作模块引入，webpack是可以直接进行打包的，究其原因，webpack本身就是用node.js(基于node环境)编写而成。但是一个网页里肯定有其他形形色色不同种类的资源，css/img/html等其他资源。webpack将这些资源统一识别为模块，你可以在任意模块之间引入这些模块</p>",
  "<pre class='language-javascript'><code class='language-javascript' lang='javascript'>// myComponent.js 引入了style.css这个样式文件",
  "import &#39;./css/style.css&#39;",
  "",
  "const div = document.createElement(&#39;div&#39;)",
  "</code></pre>",
  "<p>这个css文件在webpack的默认配置下是不会生效的，因为默认情况下webpack只能识别json/js以及模块化引入、导出的语法。为了让webpack拥有可以识别这些模块的能力，我们需要回到<code>webpack.config.js</code>中进行配置。</p>",
  "<pre class='language-javascript'><code class='language-javascript' lang='javascript'>module.exports = {",
  "// 省略entry以及output",
  "...",
  "// 与entry/output并列一个层级的还有module,其代表模块的解析方式",
  "module:{",
  "// rules : Object[]，其中可以有不同种类型的文件需要用到的不同loader",
  "rules:[",
  "{",
  "test:/\\.css$/,",
  "// css-loader用于css文件的解析，style-loader负责将解析后的css样式通过style标签的形式插入html的head标签中",
  "use:[",
  "// 完整写法如下，可以继续为loader配置其所需要的参数",
  "// {loader : &#39;style-loader&#39; , options : ...}",
  "&#39;style-loader&#39;,",
  "// use数组中loader的执行顺序是从后往前、从下至上的",
  "&#39;css-loader&#39;",
  "]",
  "},",
  "// 以less文件为例，如果使用了此种css预处理器，则需要将其转换为合法的css文件，npm中可以使用lessc将less文件转换成css，less-loader的作用也是如此",
  "{",
  "test:/\\.less$/,",
  "use:[",
  "&#39;style-loader&#39;",
  "&#39;css-loader&#39;,",
  "&#39;less-loader&#39;",
  "]",
  "}",
  "]",
  "}",
  "}",
  "</code></pre>",
  "<h3>额外补充 - postcss</h3>",
  "<p>postcss是一个使用javascript对css样式文件进行转化的一个插件，我们可以通过webpack读取postcss的配置来使项目中的css文件进行某种改变，通常用作添加浏览器前缀以及识别最新的css特性。postcss可以的功能和webpack一样，同样是通过添加plugins来实现，比如autoprefixer以及postcss-preset-env</p>",
  "<pre class='language-javascript'><code class='language-javascript' lang='javascript'>module.exports = {",
  "...",
  "module:{",
  "rules:[",
  "{",
  "test:/\\.css$/,",
  "use:[",
  "&#39;style-loader&#39;,",
  "&#39;css-loader&#39;,",
  "// 这里展现了loader的完整写法，因为需要向其中传入options",
  "{",
  "loader:&#39;postcss-loader&#39;,",
  "postCssOptions:{",
  "plugins:[",
  "// 这里的插件需要提前通过npm install autoprefixer进行下载",
  "// 需要优先于css-loader对css代码进行修改",
  "require(&#39;autoprefixer&#39;)",
  "]",
  "}",
  "}",
  "]",
  "},",
  "]",
  "}",
  "}",
  "</code></pre>",
  "<p>上面代码的意思是首先为postcss这个工具，注入autoprefixer这个插件的功能，使得postcss这个工具可以拥有向项目中的css样式里需要添加不同浏览器前缀的css属性的功能。</p>",
  "<p>但是postcss的配置写在webpack的配置文件里显得十分verbose，更好的实践是提取postcss的配置，和<code>webpack.config.js</code>一样，在项目的根目录下创建一个postcss.config.js文件:</p>",
  "<pre class='language-javascript'><code class='language-javascript' lang='javascript'>module.exports = {",
  "plugins:[",
  "// 该插件已经覆盖了autoprefixer的功能，同时还可以识别最新的css特性，例如 color : #12345678 , 此种css写法大部分浏览器是不支持的，这会使插入style中的css代码会自动将其转化为兼容性高的rgba颜色",
  "require(&#39;postcss-preset-env&#39;)",
  "]",
  "}",
  "</code></pre>",
  "<h3>(L7)webpack处理其他资源 </h3>",
  "<h4>webpack处理图片资源 - fileLoader</h4>",
  "<p>一般项目里使用图片资源有两种方式：</p>",
  "<ol>",
  "<li>通过设置DOM元素的background-image，在url()中指定</li>",
  "<li>创建img标签并指定src</li>",
  "",
  "</ol>",
  "<p>通过设置background-image属性引入的图片文件会自动被webpack识别为模块，默认情况下这些png或者jpg格式的图片文件不能被webpack正确的解析，需要引入fileLoader对这类资源做解析</p>",
  "<pre class='language-javascript'><code class='language-javascript' lang='javascript'>module.exports = {",
  "module:{",
  "rules:[",
  "{",
  "test:/\\.(jpg|png|gif)/,",
  "// 此处因为需要对file-loader进行参数设置，且只需要用到一个loader，可以直接传递一个对象给use",
  "use:{",
  "loader:&#39;file-loader&#39;,",
  "options:{",
  "// 所有匹配到的图片文件在构建出的打包文件夹中的img目录下",
  "outputPath:&#39;img&#39;,",
  "// 中括号内的为webpack内置的占位符",
  "name:&#39;[name]_[hash:6].[ext]&#39;",
  "// 或者可以直接指定输出的路径",
  "// name:&#39;img/[name]_[hash:6].[ext]&#39;",
  "}",
  "}",
  "}",
  "]",
  "}",
  "}",
  "</code></pre>",
  "<p>而如果我们在某些img标签中的src属性写死为某一个相对路径，最终通过构建出来的html标签经过渲染后，src依然是相对路径。在SPA中，因为所有的DOM元素都被挂载在index.html的id为app的div下，index.html又默认存在于dist文件夹的根路径中，形如下文的img标签就会因为加载不到所需要的资源而显示一个开裂的图片的图片占位符:</p>",
  "<pre class='language-javascript'><code class='language-vue' lang='vue'>// 开发环境下写出的img标签，例如引入了同文件夹下的xxx.png",
  "&lt;img src=&quot;./xxx.png&quot;/&gt;",
  "// 那么其在最终渲染出的html中会依然保持如上的路径不变化",
  "// 正确的做法应该是将图片资源当做模块引入并且当作3值传给img标签的src属性",
  "import XXX from &#39;./xxx.png&#39;",
  "&lt;img :src=&quot;XXX&quot;/&gt;",
  "// 这样做webpack就会将图片作为依赖关系图中的一个依赖对依赖的图片文件进行打包，这些文件和background-image中设置的图片一样会被输出到对应的目录下，最终渲染到html中的src路径也会变成部署到服务器时这个依赖的图片的路径",
  "</code></pre>",
  "<h4>将图片资源转换成base64格式的url-loader</h4>",
  "<p>Url-loader的功能可以完美覆盖file-loader的功能，将项目中用到的资源模块打包到dist文件夹中，唯一不同的是url-loader可以设置一个limit，将文件大小较小的文件转换成base64格式的文件，随着bundle.js生成到style标签里插入到index.html中(如果配置了css提取，则会提取到css打包文件中)：</p>",
  "<pre class='language-javascript'><code class='language-javascript' lang='javascript'>module.exports = {",
  "...,",
  "module:{",
  "rules:[",
  "{",
  "test:/\\.jpg$/,",
  "// 可以直接替换file-loader，同时设置options中的limit属性来将需要转换成base64格式的图片进行单独转换",
  "use:{",
  "loader:&#39;url-loader&#39;,",
  "options:{",
  "// 100KB以下的图片文件统统转换成base64格式的文件",
  "limit: 100 * 1024 , // 此处limit的单位是Byte",
  "}",
  "}",
  "}",
  "]",
  "}",
  "}",
  "</code></pre>",
  "<h4>Webpack5中对于静态资源打包的新写法 - module asset type</h4>",
  "<p>webpack5中新推出了可以替换file-loader以及url-loader的内置写法，可以不用下载前面所说的两个loader.</p>",
  "<h3>Plugins</h3>",
  "<p>loaders仅在打包过程中遇到不同类型的资源时，需要引入不同的loaders以对资源进行打包，除此以外的功能都需要通过webpack plugins来实现。plugins的使用方法就是在webpack.config.js与entry/output/module平级的plugins属性里（数组），创建一个plugin的实例以使用:</p>",
  "<pre class='language-javascript'><code class='language-javascript' lang='javascript'>import { ClearWebpackPlugin } from &#39;clear-webpack-plugin&#39;",
  "// 第三方插件的使用方法不尽相同，上方的方法需要通过解构返回，下方的方法则可以直接导出",
  "import HTMLWebpackPlugin from &#39;HTMLWebpackPlugin&#39;",
  "",
  "module.exports = {",
  "...,",
  "plugins:[",
  "new ClearWebpackPlugin(),",
  "new HTMLWebpackPlugin()",
  "]",
  "}",
  "</code></pre>",
  "<h4>基础Plugin</h4>",
  "<h5>ClearWebpackPlugin</h5>",
  "<p>使用webpack对项目进行打包的输出过程中，前一次打包的内容如果不进行手动删除，构建出的文件夹下仍然会保留前一次打包的内容，ClearWebpackPlugin可以在新一次打包的开始之前将旧的打包文件删除</p>",
  "<h5>HTMLWebpackPlugin</h5>",
  "<p>目前打包出来的文件只有资源和js文件，其都需要通过手动引入的方式放在index.html中才可以展示。</p>",
  "<p>HTMLWebpackPlugin可以让用户自行选择模版，在打包过程中自动将项目所需要的所有资源进行引入。</p>",
  "<p>模版中的一些EJS格式模版需要通过webpack官方自带的DefineWebpackPlugin进行定义和插入。</p>",
  "<h5>CopyWebpackPlugin</h5>",
  "<p>通过观察vue-cli打包出来的文件可以发现，dist文件夹下还有一个favicon文件，这个文件没有在项目中进行引入，而是直接复制到dist文件夹下的，CopyWebpackPlugin的功能就是将项目中的文件夹直接复制到构建出的文件当中。</p>",
  "<h5>WebpackDefinePlugin</h5>",
  "<p>在vue项目中的public文件夹下存放着生成的index的html模板，和通过代码编辑器生成的默认html5模板不同，这个index.html里面引入noscript标签和一些其他文件，例如favicon，前面会有一串EJS格式的变量名，形如&lt;%BASE_URL%&gt;，这个是可以通过webpack内置的插件definePlugin定义在webpack打包过程中的变量，在webpack.config.js中通过此插件配置的变量，最终在生成的index.html里都会被翻译</p>",
  "<h3>(L8)对Javascript编译的Babel以及babel-loader</h3>",
  "<p>babel其实和postcss很相似：</p>",
  "<ol>",
  "<li><p>都属于工具链的一种，只不过babel是的功能主要是将ES6及以上的javascript代码（还包括React中的jsx，vue中的SFC . vue文件）转换成浏览器能够识别的ES5代码。</p>",
  "</li>",
  "<li><p>babel和postcss一样都可以单独使用（不结合webpack中对应的babel-loader以及postcss-loader），使用的方式都是输入核心指令，然后指定要转化的文件以及转化后文件需要被输出到的目标路径地址</p>",
  "<pre class='language-javascript'><code class='language-javscript' lang='javscript'>// 在cli中需要输入的 pesudo code",
  "@babel/core ./foo.js --output ./build",
  "</code></pre>",
  "</li>",
  "<li><p>因为两者都是工具链文件，所以两者的使用方法都需要借助plugins插件或者是presets才能达到预期的效果，例如postcss中需要指定autoprefixer以及其他的插件才能给css添加浏览器前缀，babe有专门用来解析箭头函数的@babel/transform-arrow-function以及解析const/let 关键字的插@babel/transform-block-scoping。当然，用的最多的还是包含解析功能最多的预设@babel/preset-env</p>",
  "<pre class='language-javascript'><code class='language-javascript' lang='javascript'>module.exports = {",
  "...,",
  "module:{",
  "rules:[",
  "{",
  "test:/\\.js$/,",
  "use:{",
  "loader:&#39;babel-loder&#39;,",
  "options:{",
  "// 需要解析的语法都需要一个一个配置，但是实际开发中，开发者不可能一一对这些语法进行配置",
  "// 所以babel-loader同样支持presets配置，preset中已经预设好了开发者实际开发过程中需要被转化的高级代码",
  "plugins:[",
  "&#39;@babel-transform-arrow-function&#39;,",
  "&#39;@babel-transform-block-scoping&#39;",
  "],",
  "// 预设包括但不限于上述plugins的功能",
  "presets:[",
  "&#39;babel-presets-env&#39;",
  "]",
  "}",
  "}",
  "}",
  "]",
  "}",
  "}",
  "</code></pre>",
  "</li>",
  "",
  "</ol>",
  "<h4>babel 编译原理了解</h4>",
  "<p>Compiler 编译器先对代码进行词法分析，拆除<code>const name = &quot;Hello World&quot;</code>中的每一个连续的有效字符放进token 数组中，再通过parsing(语法分析)去解析数组中哪些是有效关键字、哪些是变量名、操作符……，解析完毕后的代码会生成一个ast抽象语法树再交由js引擎执行，babel发挥作用的地方就是在已经解析成ast的高级代码后引用插件对其中浏览器可能不认识的描述进行重写，由ast-&gt;浏览器能够识别的ast</p>",
  "<h3>Single File Component SFC - .vue文件</h3>",
  "<p>目前演示运行vue所使用的vue版本为vue.global.js，这个版本的vue就是官网上可以下载到的vue，（CDN上可以下载到的vuejs也是这个版本），这个版本的vue是只包含runtime版本的，不包含compiler版本，也就是说如果我们在createApp函数里传递的组件中含有template属性（如果包含模版），index.html中是没办法渲染的，需要选用包含runtime+compiler的版本。</p>",
  "<p>.vue结尾的sfc文件之所以不需要Compiler版本的vue是因为vue-loader依赖的插件vue-compiler-sfc拥有解析模版的能力，所以项目依赖中的vue就不需要包含compiler版本，只需要runtime版本就可以，将编译模版的工作放在打包时进行，以达到缩小项目体积的作用（因为不需要引入包含compiler版本的vue）</p>",
  "<h3>webpack的watch模式与webpack-dev-server</h3>",
  "<p>目前我们对项目进行打包的操作都是手动进行的，每次修改完项目源代码都要输入<code>npm run build</code>然后手动刷新浏览器才可以看到变化后的代码。如果开发者能够在修改一行源代码以后，webpack监听到变化事件然后自动打包文件就好了，watch模式就是为此而生的:</p>",
  "<pre class='language-javascript'><code class='language-javascript' lang='javascript'>module.exports = {",
  "...",
  "watch:true",
  "...",
  "}",
  "</code></pre>",
  "<p>但是这个开发模式有一个问题，就是开发者还是必须要手动刷新浏览器才能看到更改之后的效果，所以比较好的实践是安装webpack-dev-server。</p>",
  "<p>webpack-dev-server会使用express在本地开启一个服务器，项目中的代码在更新并且保存后会自动打包并且保存在本地的内存之中（不会输出任何文件），项目代码对该服务器的访问都将直接读取内存中的打包文件并且返回给浏览器做展示，省去了读取生成的本地文件到内存中，再由服务器将内存中的代码返回给浏览器这一过程。</p>",
  "<h4>devServer - contentBase</h4>",
  "<p>devserver的配置之一是contentBase，如果项目中请求的资源不能被访问到，devserver就会转而在contentbase设置的路径下寻找项目中请求的资源。例如开发者不希望在开发过程中使用webpack插件CopyWebpackPlugin对favicon进行复制favicon到dist文件夹的操作，index.html中请求favicon的地址就会访问不到favicon文件，而此时将contentBase设置成存放favicon的public文件，webpack提供不到的favicon就会去pulic文件夹路径下寻找favicon文件</p>",
  "<h4>devServer - hot </h4>",
  "<p>热模块替换开启后，webpack会将每一个.js文件当做一个模块，模块中增加或者删除代码以后，只有这一个模块的代码更新会反应到浏览器当中，浏览器不会进行刷新，因此可以保留其他组件或者模块里的状态。</p>",
  "<p>在webpack.config.js中配置hot为true后，还需要为每一个模块都添加对应的模块更新的响应逻辑：</p>",
  "<pre class='language-javascript'><code class='language-javascript' lang='javascript'>// 必须添加以下代码，才能实现局部更新",
  "// .vue文件(或者react项目中的jsx文件)不需要写这些，因为vue-loader会帮我们处理好添加//以下代码的步骤",
  "if(module.hot){",
  "module.hot.accept(&#39;./demo.js&#39;),()=&gt;{",
  "//监听到文件变化后的回调",
  "}",
  "}",
  "</code></pre>",
  "<p>其原理是，启动webpack-dev-server的时候，会默认开启一个express静态资源服务器，在开发过程中根据依赖树打包出来的js/css/html等静态资源会储存在内存当中，当我们访问本机默认端口时，服务器就会将内存中的静态资源读取出来返回给客户端浏览器。</p>",
  "<p>HMR的开启就相当于开启了另一个HMR服务，开发过程中如果我们改动了某一个文件，HMR服务就会生成：</p>",
  "<ol>",
  "<li>一个manifest清单文件，该文件描述了整个依赖树中哪一个文件发生了改动</li>",
  "<li>一个新的改动过的js文件，该文件就是需要被替换的js文件</li>",
  "",
  "</ol>",
  "<p>被替换的文件会被浏览器端重新请求，因此浏览器端就相当于只更新了部分文件，而不需要全量刷新整个html页面</p>",
  "<p>vue-loader中已经为每一个.vue文件添加过了这样的逻辑，所以开发者不需要添加这个响应逻辑</p>",
  "<h4>devServer - resolve</h4>",
  "<p>webpack中解析模块的模式有三种：</p>",
  "<ol>",
  "<li>绝对路径：跟上盘符以及路径的绝对路径</li>",
  "<li>相对路径：相对于正在编写的文件目录路径向上级或者下级查找文件的方式 </li>",
  "<li>模块路径 -  比如<code>import {createApp} from &#39;vue&#39;</code>，这种查找方式就是模块路径，默认情况下webpack会去项目根目录中的node_modules查找vue模块，这个默认行为其实就是在webpack.config.js配置文件中的resolve中可配置的</li>",
  "",
  "</ol>",
  "<p>resolve主要配置的是文件的扩展名以及alias</p>",
  "<pre class='language-javascript'><code class='language-javascript' lang='javascript'>import {createApp} from &#39;vue&#39;",
  "",
  "// resolve中最常配置的两个属性就是extensions以及alias",
  "module.exports = {",
  "resolve:{",
  "extensions:[&#39;.wasm&#39;,&#39;.js&#39;], // 因为默认情况下这里有配置.js等，所以js文件是不需要写后缀名的",
  "",
  "// 很多时候引入模块的时候会跳很多级目录",
  "// 比如 import Demo from &#39;../../../../../demo.js&#39;",
  "// 如上的写法不直观很容易出错，所以为了方便开发，可以采取取别名的方式，写法如下：",
  "alias:{",
  "&quot;@&quot;:path.resolve(__dirname,&#39;./src&#39;)",
  "&quot;js&quot;:path.resolve(__dirname,&#39;./src/js&#39;)",
  "}",
  "}",
  "}",
  "</code></pre>",
  "<h2>Vue3</h2>",
  "<h4>非props属性的attribute</h4>",
  "<pre class='language-javascript'><code class='language-vue' lang='vue'>// 父组件",
  "&lt;template&gt;",
  "&lt;Son class=&#39;demo&#39;&gt;&lt;/Son&gt;",
  "&lt;/template&gt;",
  "",
  "// 子组件",
  "&lt;template&gt;",
  "// 默认情况下，子组件外层的fragment，也就是这个包裹div会默认继承这个非props的attribute，也 // 就是下面这个div会是&lt;div class=&#39;demo&#39;&gt;&lt;/div&gt;这个样子",
  "&lt;div&gt;",
  "&lt;li :class=&quot;$attrs.class&quot;&gt;demo&lt;/li&gt;",
  "&lt;/div&gt;",
  "&lt;/template&gt;",
  "</code></pre>",
  "<p>像class和style这些不会显式传递给子组件的attribute属性，默认情况下，这个attr会传递给包裹子组件外侧的包裹元素（根组件）</p>",
  "<p>如果需要子组件中的元素共享到上层传递的非props的attribute，则需要通过如上this.$attrs.class来访问父组件传递过来的非props的attribute属性。</p>",
  "<h4>$emit</h4>",
  "<p>父子组件通信中，子组件向父组件传递参数的时候，vue2中和vue3中稍许有些不同，那就是在配置项中需要显式地注册子组件emit的事件名称</p>",
  "<pre class='language-javascript'><code class='language-javascript' lang='javascript'>export default{",
  "emits:[&#39;add&#39;,&#39;minus&#39;,&#39;addN&#39;],",
  "methods:{",
  "handleAddClicked(){",
  "this.$emit(&#39;addN&#39;,100)",
  "}",
  "}",
  "}",
  "</code></pre>",
  "<h4>非父子组件传参 provide / inject </h4>",
  "<p>适用于祖孙组件互相传参，在祖组件实例对象中配置provide属性，在孙组件中使用inject属性</p>",
  "<pre class='language-javascript'><code class='language-javascript' lang='javascript'>//祖组件",
  "import { computed } from &#39;vue&#39;",
  "",
  "export default{",
  "provide:{",
  "name:&#39;haha&#39;,",
  "age:18",
  "}",
  "// 需要注意的是provide使用对象字面量写法，属于一次性传参，如果需要孙组件可以跟着动态变化的话需要使用provide的函数式写法，且使用setup中的computed写法，至此，computed参数函数中的依赖如果发生变化，该值就会重新计算并传递给使用inject的孙组件",
  "",
  "provide(){",
  "// 注意如果不是使用函数式写法的provide会报错，因为this指向undefined",
  "return {",
  "name:&#39;haha&#39;,",
  "age:18,",
  "length:computed(()=&gt; this.data.length )",
  "}",
  "}",
  "}",
  "//孙组件需要使用inject配置项注入provide中的属性",
  "export default{",
  "inject:[&#39;name&#39;,&#39;age&#39;]",
  "}",
  "",
  "",
  "</code></pre>",
  "<h4>mitt</h4>",
  "<p>vue3事件总线写法删除了$on/$off等原vue2中的写法，因此如果想在兄弟组件之间传递信息的话可以使用第三方库，官方推荐的库为mitt，写法与vue2中的类似.</p>",
  "<pre class='language-javascript'><code class='language-javascript' lang='javascript'>import Mitt from &#39;mitt&#39;",
  "export const emitter = new Mitt()",
  "",
  "emitter.emit(&#39;eventA&#39;,param)",
  "",
  "emitter.on(&#39;eventA&#39;,()={ // eventA callback})",
  "</code></pre>",
  "<h3>插槽slot</h3>",
  "<pre class='language-javascript'><code class='language-vue' lang='vue'>// 父组件App.vue",
  "&lt;template&gt;",
  "&lt;Son&gt;",
  "&lt;template v-slot:slotA&gt;",
  "foo bar",
  "&lt;/template&gt;",
  "// 作用域插槽",
  "&lt;template v-slot=&quot;slotProps&quot;&gt;",
  "{{slotProps.index}}",
  "&lt;/template&gt;",
  "&lt;/Son&gt;",
  "&lt;/template&gt;",
  "",
  "// 子组件Son.vue",
  "&lt;template&gt;",
  "&lt;div&gt;",
  "&lt;slot name=&quot;slotA&quot;&gt;&lt;/slot&gt;",
  "&lt;slot :index=&quot;index&quot;&gt;&lt;/slot&gt;",
  "&lt;/div&gt;",
  "&lt;/template&gt;",
  "</code></pre>",
  "<h3>动态组件 <component></component></h3>",
  "<p>渲染一个tab页可以有很多种方式</p>",
  "<ol>",
  "<li>Router-view通过注册路由来渲染</li>",
  "<li>通过v-if判断当前选中的tab项来判断是否渲染</li>",
  "<li>通过动态组件指定component组件的is属性来渲染</li>",
  "",
  "</ol>",
  "<pre class='language-javascript'><code class='language-vue' lang='vue'>&lt;template&gt;",
  "&lt;component :is=&quot;currentChosen&quot;&gt;&lt;/component&gt;",
  "&lt;/template&gt;",
  "",
  "&lt;script&gt;",
  "import Home from &#39;./home&#39;",
  "import About from &#39;./about&#39;",
  "",
  "export default {",
  "data(){",
  "return {",
  "// 注意此处currentChosen只与下文components属性中注册的组件名有关，在compoents属性中注册的属性如果是大写，is属性后可跟组件的大写或者小写",
  "currentChosen:&#39;&#39;",
  "}",
  "},",
  "components:{",
  "Home,About",
  "}",
  "}",
  "&lt;/script&gt;",
  "</code></pre>",
  "<h3>keep-alive</h3>",
  "<p>另一个内置组件是keep-alive，keep-alive包裹着的组件在切换组件的过程中默认不会被销毁，需要指定keep-alive的include或者exclude属性来指定哪一些组件需要被缓存起来/不需要被缓存起来（这里的缓存指保留该组件离开前的状态）</p>",
  "<p>注意跟在include和exclude后边的是组件的名称，也就是组件options里可以指定的name属性，不要与动态组件中is后跟着的组件名称搞混：</p>",
  "<pre class='language-javascript'><code class='language-vue' lang='vue'>&lt;template&gt;",
  "&lt;keep-alive include=&quot;home,about&quot;&gt;",
  "&lt;component :is=&quot;currentChosen&quot;&gt;&lt;/component&gt;",
  "&lt;/keep-alive&gt;",
  "&lt;/template&gt;",
  "",
  "//注意上述include包含的组件名称是组件options中的name属性，而不是局部注册或者全局注册在components中的名称，不要搞混",
  "</code></pre>",
  "<h3>webpack打包文件分包/ vue3中的异步组件</h3>",
  "<p>vue-cli底层依赖webpack对项目进行构建，默认情况下我们编写的代码会被打包在app[hash].js文件当中，第三方的文件代码会被打包进vendor_chunk[hash].js文件中，这就导致一个问题，如果我们的编写的代码和组件很多就会导致app.js的体积特别大，浏览器首次请求我们的页面时就要一并下载app.js，如果app.js没有下载完成我们的页面就没法完成渲染，这是<code>首屏加载</code>缓慢的原因之一。构建文件分包的意思是对于某些组件或者代码，由我们手动指定特殊的方式引入，这样webpack在对这段代码进行打包的时候就会单独打包一个chunk，等到浏览器闲暇时或者真正要加载这一个页面时才会下载这一段chunk.js。</p>",
  "<pre class='language-javascript'><code class='language-javascript' lang='javascript'>// math.js",
  "function sun (a, b) return a + b",
  "",
  "// 在别处引入，采用import的函数调用写法，其返回一个promise，模块中的函数可以通过取promise返回的结果中的属性进行获取",
  "import(&#39;./utils/math.js&#39;).then(res=&gt;{",
  "res.sum(1,2)",
  "})",
  "</code></pre>",
  "<p>vue3中想要定义异步加载的组件和webpack的写法很相似，需要从vue引入<code>defineAsyncComponent</code>函数，该函数接收一个返回值为promise对象的函数，如上所说，使用import的函数调用写法返回的就是一个promise对象，这样的写法与上述webpack中打包文件分包的写法不谋而合，经由此进行引入的异步组件会被单独打包处理.</p>",
  "<pre class='language-javascript'><code class='language-javascript' lang='javascript'>import { defineAsyncComponent} from &#39;vue&#39;",
  "",
  "const MyComponent = defineAsyncComponent(() =&gt; import (&#39;./mycomponent.vue&#39;))",
  "",
  "// .. 省略正常注册以及使用的步骤",
  "</code></pre>",
  "<p>异步组件还可以和vue中的内置组件Suspense一起使用，suspense的含义是”悬而未决的“，被suspense包裹的部分是使用插槽进行插入的异步组件，默认情况下会加载我们想要防止的异步组件，另一个插槽可以防止我们想要在此异步组件没有被加载出来前显式的占位组件。</p>",
  "<pre class='language-javascript'><code class='language-vue' lang='vue'>&lt;Suspense&gt;",
  "&lt;template #defualt&gt;",
  "&lt;SomeAsyncComponent&gt;&lt;/SomeAsyncComponent&gt;",
  "&lt;/template&gt;",
  "&lt;template #fallback&gt;",
  "&lt;div&gt;",
  "Loading...",
  "&lt;/div&gt;",
  "&lt;/template&gt;",
  "&lt;/Suspense&gt;",
  "</code></pre>",
  "<h4>关于在组件中使用v-model</h4>",
  "<p>前面已经讨论过在表单组件中使用v-model，在组件中使用v-model会有一些不一样的特性</p>",
  "<pre class='language-javascript'><code class='language-vue' lang='vue'>// 父组件template中的用法",
  "&lt;MyInputComponent v-model=&quot;message&quot; v-model:newVal=&quot;newValInParentComponent&quot;&gt;&lt;/MyInputComponent&gt;",
  "",
  "// 子组件MyInputComponent中",
  "&lt;template&gt;",
  "&lt;input :value=&quot;modelVaule&quot; @input=&quot;handleInput&quot;/&gt;",
  "&lt;input :value=&quot;modelVaule2&quot; @input=&quot;handleInput2&quot;/&gt;",
  "&lt;/template&gt;",
  "",
  "&lt;script&gt;",
  "export default {",
  "props:{",
  "// 默认传递过来的就是modelValue这个值",
  "modelValue:{},",
  "newVal:{}",
  "},",
  "methods:{",
  "handleInput($event){",
  "// 注意这里的&#39;update:model-value&#39;为固定写法，如果需要同时绑定多个值，update后需要跟上对应的值名称",
  "this.$emit(&#39;update:model-value&#39;,$event.target.value)",
  "},",
  "handleInput($event){",
  "this.$emit(&#39;update:new-val&#39;,$event.target.value)",
  "}",
  "}",
  "}",
  "&lt;/script&gt;",
  "",
  "</code></pre>",
  "<h3>过渡动画(new)</h3>",
  "<h4>单节点过渡动画</h4>",
  "<p>GreenSock Animation Platform (以下简称gsap) 为vue官方文档演示动画时使用的第三方库，其特点是通过javascript来控制动画，一般使用在transition组件的js钩子函数中来控制元素动画</p>",
  "<p>在vuejs中不光可以使用简单的css transition或者 css animation来指定单个元素的动画，还可以设置js钩子</p>",
  "<pre class='language-javascript'><code class='language-vue' lang='vue'>&lt;transition @enter=&quot;animationEnter&quot;&gt;",
  "&lt;someComponent v-if=&quot;isShow&quot;&gt;&lt;/someComponent&gt;",
  "&lt;/transition&gt;",
  "",
  "&lt;script&gt;",
  "export default{",
  "methods:{",
  "animationEnter(el,done){",
  "// 此处使用gsap动画库里的to函数指定元素动画enter触发时，元素原本的状态",
  "// js钩子控制的动画相较于css animation的优势在于，可以动态指定动画的变量",
  "gsap.from(el,{",
  "x:-100,",
  "onComplete:done",
  "}",
  "}",
  "}",
  "&lt;/script&gt;",
  "</code></pre>",
  "<h4>多节点过渡动画 transition-group</h4>",
  "<p>多节点的过渡动画一般是用在列表里的值有变化，列表项item需要进行移动时产生的动画。</p>",
  "<pre class='language-javascript'><code class='language-vue' lang='vue'>&lt;template&gt;",
  "// 此处tag后边的传参为包裹在li外侧的元素标签，可以指定为任何元素",
  "// transition-group 中的元素必须指定唯一的key",
  "&lt;transition-group tag=&quot;p&quot; name=&quot;zya&quot;&gt;",
  "&lt;li v-for=&quot;item in itemList&quot; :key=&quot;item&quot;&gt;&lt;/li&gt;",
  "&lt;/transition&gt;",
  "&lt;/template&gt;",
  "",
  "&lt;script&gt;",
  "export default{",
  "data(){",
  "return {",
  "itemList:[1,2,3,4,5,6,7,8,9]",
  "}",
  "}",
  "}",
  "&lt;/script&gt;",
  "",
  "&lt;style lang=&quot;less&quot; scoped&gt;",
  "// 注意，仅仅指定&lt;li&gt;的动画，比如插入、删除的时候，剩余的元素的位移会是瞬间的，解决的方式是加入和transition组件name联动的的&#39;v-move&#39; css Class",
  ".zya-enter-from,",
  ".zya-leave-to{",
  "opacity:0 ,",
  "transform:translateY(30px)",
  "}",
  "",
  ".zya-enter-active,.zya-leave-active{",
  "transition:all .4s ease;",
  "}",
  "// v-move css类",
  ".zya-move{",
  "// 此处不需要指定translate的具体值，直接设置其余元素的transform过渡属性就可以",
  "transition:transform 1s ease;",
  "}",
  "// 还需要注意的是，&lt;li&gt;在删除动画执行过程中，可能会出现一个问题，就是还没有完全删除的&lt;li&gt;在执行删除动画的时候还是占据了他本身的宽度，继续占据着文档流，解决的方法是，在删除动画执行过程中，设置其position属性为absolute可以解决，此为vue3官方文档的处理方式",
  ".zya-leave-active{",
  "position:absolute",
  "}",
  "",
  "&lt;/style&gt;",
  "</code></pre>",
  "<h4>transition-group中给每个item的动画设置不同的delay</h4>",
  "<p>视频中想要实现的动画效果是每一个收起的item的高度会一个一个缩小为0，透明度变为0，如果所有的item都同时消失，这样的动画效果并不是特别理想，我们想要从上往下依次给每个消失的item设置动画的delay且delay的时长不尽相同，css transition和keyframes动画不能很好的实现这种效果，因此只能在js钩子函数中实现，以下是实操代码：</p>",
  "<pre class='language-javascript'><code class='language-vue' lang='vue'>&lt;template&gt;",
  "&lt;div&gt;",
  "&lt;input type=&quot;text&quot; v-model=&quot;inputval&quot;&gt;",
  "// transition-group中设置css属性为false，vue会取消嗅探元素是否使用了css过渡以及动画，以避免因为同时使用钩子和css动画引起的动画不一致冲突",
  "&lt;transition-group tag=&quot;p&quot; name=&quot;zya&quot; @enter=&quot;enter&quot; @leave=&quot;leave&quot; :css=&quot;false&quot;&gt;",
  "// 在钩子函数中vue会默认传入进行动画的元素的el，即为元素的DOM，data-foo形式的属性传递最后都可以在元素的dataset中获取到",
  "// 给每个不同的进行动画的元素绑定一个不同的data-index后在gsap中通过变量控制不同的delay即可",
  "&lt;li v-for=&quot;item in computedList&quot; :key=&quot;item&quot; :data-index=&quot;item&quot;&gt;",
  "{{item}}",
  "&lt;/li&gt;",
  "&lt;/transition-group&gt;",
  "&lt;/div&gt;",
  "&lt;/template&gt;",
  "",
  "&lt;script&gt;",
  "import gsap from &#39;gsap&#39;",
  "",
  "export default {",
  "data(){",
  "return {",
  "inputval:&#39;&#39;,",
  "itemList:[1,2,3,4,5,6,7,8]",
  "}",
  "},",
  "watch:{",
  "",
  "},",
  "computed:{",
  "computedList(){",
  "if(this.inputval){",
  "return this.itemList.filter(item =&gt; item == this.inputval)",
  "}else{",
  "return this.itemList",
  "}",
  "",
  "}",
  "},",
  "methods:{",
  "enter(el,done){",
  "gsap.from(el,{",
  "x:100,",
  "opacity:0,",
  "height:0,",
  "onComplete:done",
  "})",
  "gsap.to(el,{",
  "x:0,",
  "opacity:1,",
  "height:&quot;1.5em&quot;,",
  "onComplete:done",
  "})",
  "},",
  "leave(el,done){",
  "gsap.to(el,{",
  "y:0,",
  "delay:(function(){",
  "console.log(el.dataset.index * .3)",
  "return el.dataset.index * .1",
  "}()),",
  "height:0,",
  "opacity:0,",
  "onComplete:done",
  "})",
  "}",
  "}",
  "}",
  "&lt;/script&gt;",
  "",
  "// 因为transition-group中设置了css为false，所以如下代码并不会影响到js钩子函数动画的执行",
  "&lt;style lang=&quot;less&quot; scoped&gt;",
  ".zya-leave-active{",
  "position: absolute;",
  "}",
  ".zya-move{",
  "transition: transform .4s ease;",
  "}",
  "&lt;/style&gt;",
  "</code></pre>",
  "<h3>Composition API(new)</h3>",
  "<h4>setup函数的参数</h4>",
  "<p>使用options API进行vue项目的编写是有弊端的，同一处逻辑的关注点被分离到了各种各样的options中，比如要写一个counter组件，我们一会儿要去data里面找counter计数的变量，一会儿要去找methods里面，我们点击button对counter进行的操作。一个两个组件还找的过来，但是当组件的代码量变得庞大起来后，编写的代码找起来就比较费劲了。</p>",
  "<p>Composition API致力于将同一个组件的代码逻辑抽到一个hook里面（组件逻辑合并起来）我们直接在setup函数中对这个hook进行调用就可以实现和Options API相同的效果</p>",
  "<p>Setup函数是一个组件的属性，有了setup函数就不需要去编写传统的options（诸如data,methods,computed等等属性了，但是需要编写props来指定允许传递进组件的props属性）</p>",
  "<pre class='language-javascript'><code class='language-vue' lang='vue'>&lt;script&gt;",
  "export default{",
  "setup(props , ctx){",
  "// 注意setup函数中是不可以使用this的",
  "// vue会默认将组件的props属性传递进setup函数的第一个参数中",
  "}",
  "",
  "// 一般解构出ctx的主要功能函数",
  "setup(props , {emit , attrs, slots}){",
  "",
  "}",
  "}",
  "&lt;/script&gt;",
  "</code></pre>",
  "<h4>setup的返回值</h4>",
  "<p>setup既然是一个函数，那就必然有返回值，setup函数的返回值可以是一个对象，对象里的属性可以被template模版使用，但是返回值并不是响应式的.</p>",
  "<pre class='language-javascript'><code class='language-vue' lang='vue'>&lt;template&gt;",
  "// 这里是可以取到setup函数的返回值的，但是变更msg函数以后，页面不会响应式得发生更新",
  "{{msg}}",
  "&lt;/template&gt;",
  "",
  "&lt;script&gt;",
  "setup(){",
  "let msg = &#39;someMessage&#39;",
  "",
  "const foo = () =&gt; {",
  "msg = &#39;somerandomMSG&#39;",
  "}",
  "",
  "return {",
  "msg",
  "}",
  "}",
  "&lt;/script&gt;",
  "</code></pre>",
  "<h3>reactive函数/ref函数</h3>",
  "<pre class='language-javascript'><code class='language-vue' lang='vue'>&lt;template&gt;",
  "&lt;div&gt;",
  "{{state.msg}}",
  "&lt;button @click=&quot;randomOp&quot;&gt;random&lt;/button&gt;",
  "&lt;!-- ref包裹的响应式应用在模版里不需要通过访问ref的value属性来访问，我们可以直接访问定义在setup中的ref对象的名称--&gt;",
  "{{msg - &#39;msg理论上应该是ref引用对象，但在模版中不需要调用msg.value来访问其中的响应式数据，直接msg即可&#39;}}",
  "&lt;/div&gt;",
  "&lt;/template&gt;",
  "",
  "&lt;script&gt;",
  "",
  "import {reactive , ref} from &#39;vue&#39;",
  "",
  "export default {",
  "setup(){",
  "// 注意reactive函数里必须包裹一个数组或者对象，我们需要的属性通过函数返回的state对象中对应的属性去取值并且在template中进行渲染",
  "// 但是如果我们只需要一个响应式属性，还需要把数据写进一个对象再通过对象调用该属性写起来有点烦，这个时候就需要ref函数出场了，ref函数传递进去的参数可以是普通类型的数据，ref函数将其包裹成一个响应式的obj对象，我们需要访问其中的value属性来访问真正我们需要的属性",
  "const state = reactive(",
  "{",
  "msg:&quot;initial&quot;",
  "}",
  ")",
  "/*",
  "第二种写法",
  "*/",
  "const msg = ref(&#39;initialmsg&#39;)",
  "",
  "",
  "const randomOp = () =&gt; {",
  "state.msg = &#39;randomed_msg&#39;",
  "",
  "// 对应的ref写法",
  "msg.value = &#39;ref_randomed_msg&#39;",
  "}",
  "",
  "return {",
  "state,",
  "msg,",
  "randomOp",
  "}",
  "}",
  "}",
  "&lt;/script&gt;",
  "</code></pre>",
  "<h4>readonly函数</h4>",
  "<p>readonly可以接收一个响应式或者普通的对象或者基础类型变量，返回的对象内容将是只读的，不可以被修改的。</p>",
  "<pre class='language-javascript'><code class='language-vue' lang='vue'>&lt;template&gt;",
  "&lt;div&gt;",
  "{{readonlymsg}}",
  "&lt;button @click=&quot;randomOp&quot;&gt;random&lt;/button&gt;",
  "&lt;/div&gt;",
  "&lt;/template&gt;",
  "",
  "&lt;script&gt;",
  "",
  "import {reactive , ref , readonly} from &#39;vue&#39;",
  "",
  "export default {",
  "setup(){",
  "const msg = ref(&#39;initialmsg&#39;)",
  "",
  "let readonlymsg = readonly(msg)",
  "",
  "const randomOp = () =&gt; {",
  "// 这个时候如果我们如果将readonlyInfo1传递给子组件的话，子组件不可以对readonly对象里的msg属性进行修改操作，会报一个警告",
  "// 传递给子组件的内容只能通过修改父组件中的info1里的属性，响应式得影响到子组件中对info1.msg的依赖以更新视图",
  "// Vue警告⚠️:[Vue warn] Set operation on key &quot;value&quot; failed: target is readonly.",
  "// 此处以ref引用为例做修改，修改的是ref引用的value属性",
  "readonlymsg.value = &#39;ref-randomed-msg-changed&#39;",
  "}",
  "",
  "return {",
  "readonlymsg,",
  "randomOp",
  "}",
  "}",
  "}",
  "&lt;/script&gt;",
  "",
  "</code></pre>",
  "<h3>API讲解</h3>",
  "<p>这里列举一些使用频率稍高一点的API</p>",
  "<h4>toRefs/toRef</h4>",
  "<p>有时我们想对reactive对象中的某个属性进行解构，直接对reactive对象进行解构，得到的值并不是响应式的。toRefs函数接受一个reactive对象，返回一个key为原property，但value为对应property的ref对象的对象，对此对象进行解构，更改ref对象的value属性，页面时可以做到响应式刷新的</p>",
  "<pre class='language-javascript'><code class='language-vue' lang='vue'>&lt;script&gt;",
  "import { toRefs , reactive ,toRef } from &#39;vue&#39;",
  "",
  "setup(){",
  "const state = reactive({name:&#39;zya&#39;,age:26})",
  "",
  "let {name} = toRefs(state)",
  "",
  "// toRef函数也是做的相同的工作，只是API调用写法稍有不同",
  "",
  "let age = toRef(state , &#39;age&#39;)",
  "return {",
  "name,",
  "age",
  "}",
  "}",
  "",
  "&lt;/script&gt;",
  "</code></pre>",
  "<h4>computed/watchEffect</h4>",
  "<p>computed和options api中的用法比较相似，传递给computed函数一个getter函数，computed会返回一个ref对象</p>",
  "<pre class='language-javascript'><code class='language-vue' lang='vue'>&lt;script&gt;",
  "import {computed , watchEffect ,ref } from &#39;vue&#39;",
  "",
  "let firstname = ref(&#39;yiang&#39;)",
  "let lastname = ref(&#39;yiang&#39;)",
  "",
  "let fullname = computed(()=&gt; firstname.value + lastname.value)",
  "&lt;/script&gt;",
  "</code></pre>",
  "<p>watchEffect函数相当于options api中的watch选项，只不过多了一些额外的特性，比如，传递给watchEffect函数的回调函数，必然会事先调用一次以自动收集函数中所涉及的响应式依赖，并且在这些响应式依赖发生改变的时候，重新回调整个回调函数</p>",
  "<pre class='language-javascript'><code class='language-vue' lang='vue'>&lt;script&gt;",
  "import {computed , watchEffect ,ref } from &#39;vue&#39;",
  "let firstname = ref(&#39;yiang&#39;)",
  "let lastname = ref(&#39;yiang&#39;)",
  "",
  "watchEffect(()=&gt;{",
  "console.log(firstname.value)",
  "})",
  "&lt;/script&gt;",
  "</code></pre>",
  "<h4>this.$refs</h4>",
  "<p>Composition API中没有this，以往我们需要直接对一个DOM进行操作的时候，通常是在生命周期函数中通过this.$refs.DOMElement取得，refs的新写法如下:</p>",
  "<pre class='language-javascript'><code class='language-vue' lang='vue'>&lt;template&gt;",
  "&lt;div ref=&quot;title&quot;&gt;",
  "lol",
  "&lt;/div&gt;",
  "&lt;/template&gt;",
  "",
  "&lt;script&gt;",
  "import {ref} from &#39;vue&#39;",
  "",
  "setup(){",
  "// 创建一个空的容器，用title变量储存",
  "let title = ref(null)",
  "",
  "// 等到DOM进行挂载以后，便可以在生命周期函数中显示title这个DOM元素",
  "",
  "return {",
  "title",
  "}",
  "}",
  "&lt;/script&gt;",
  "</code></pre>",
  "<h4>watch</h4>",
  "<p>watchEffect和watch函数都可以监听响应式变量的变化，不同的是watch函数是惰性求值的，它不会像watchEffect函数那样默认调用一次，另外就是watch可以取到响应式变量的oldValue以及newValue，而watchEffect不可以。</p>",
  "<p>注意如果监听的是ref包裹的响应式对象，必须调用value属性，否则回调函数不执行，因为ref响应式对象的指向并没有改变。</p>",
  "<pre class='language-javascript'><code class='language-vue' lang='vue'>&lt;script&gt;",
  "import {watch , ref} from &#39;vue&#39;",
  "setup(){",
  "let name = ref({hero:&#39;shadow fiend&#39;})",
  "",
  "// watch这里可以直接传入响应式对象，默认就是深度监听",
  "watch(name.value,(newValue,oldValue)=&gt;{",
  "console.log(newValue,oldValue)",
  "})",
  "",
  "// 如果这里监听的只是ref响应式对象，是没有发生更改的，因为指向没有变，只有里面的属性做了修改从而可以被监听到，所以上下两种写法都可以监听到",
  "watch(name,(newValue,oldValue)=&gt;{",
  "console.log(newValue,oldValue)",
  "})",
  "",
  "// 如果需要监听某个响应式对象的一个属性，可以将第一个参数写为getter函数",
  "watch(()=&gt; name.value.hero,(newValue,oldValue)=&gt;{",
  "console.log(newValue,oldValue)",
  "})",
  "}",
  "&lt;/script&gt;",
  "</code></pre>",
  "<h4>生命周期钩子</h4>",
  "<p>组合式api中的生命周期钩子是通过引入对应钩子前加on的同名钩子函数调用的，比如原来在options api 中使用的mounted，在组合式api中需要先引入onMounted，然后给这个函数中传入需要执行的回调函数。</p>",
  "<h3>组件的高级用法</h3>",
  "<h4>h函数以及jsx</h4>",
  "<p>vue本身是推荐使用模版template来对组件进行编写，但是有的时候使用javascript的完全编程能力编写代码会比较方便，这时在一个SFC组件中我们可以不用编写template转而直接编写render函数。</p>",
  "<p>template模版首先会被编译compile成render函数，对渲染函数进行调用后会返回一个Virtual Node Tree，也就是一个浏览器DOM描述对象树，VNode Tree就是普通的Js对象，开销对比真实DOM很小，当页面每次进行重新渲染时，vue会通过比对原有的vnode tree和新的vnode tree，高效得保留不需要更新的部分，使得app整体运行流畅。</p>",
  "<p>由上面可知render函数应该返回一个vnode，而我们是不能直接写出vnode的，需要借助vue提供的h函数，h函数就相当于React.createElement，h函数返回的就是一个vnode。</p>",
  "<pre class='language-javascript'><code class='language-vue' lang='vue'>&lt;script&gt;",
  "import { h } from &#39;vue&#39;",
  "",
  "export default {",
  "render(){",
  "// render函数的普通写法",
  "return h(&#39;div&#39;,{class:&#39;foo&#39;},[",
  "&#39;this is some text msg&#39;,",
  "h(&#39;h1&#39;,null,&#39;bar&#39;)",
  "])",
  "// 如果需要传递插槽，第三个参数就需要传递进去一个对象，这个对象的key是对应插槽的名称，value是一个函数，返回一个vnode",
  "return h(RandomComponent,{class:&#39;foo&#39;},{",
  "// 此处就可以收到不同作用域内的数据",
  "default: props =&gt; h(&#39;div&#39;,null,&#39;i am slot message&#39;)",
  "})",
  "}",
  "}",
  "&lt;/script&gt;",
  "",
  "// randomComponent中",
  "&lt;script&gt;",
  "export default{",
  "render(){",
  "// 这里可以注意到组件可以通过this.$slots获取到所有传递到组件内的插槽，此处我们对此进行调用，就可以渲染出来传递过来的插槽了",
  "// 如果在函数调用的同时传递参数，那么定义这个插槽的父组件内就能收到子组件中传递出去的参数，这就是作用域插槽的内核",
  "return h(&#39;div&#39;,null,[",
  "this.$slots.default ? this.$slots.default(someprops) : h(&#39;span&#39;,null,&#39;lol&#39;)",
  "])",
  "}",
  "}",
  "&lt;/script&gt;",
  "</code></pre>",
  "<h4>自定义指令directives</h4>",
  "<p>自定义指令只在我们需要操作底层DOM的时候编写比较有用，自定义指令分为局部和全局的</p>",
  "<pre class='language-javascript'><code class='language-vue' lang='vue'>&lt;template&gt;",
  "&lt;input type=&quot;text&quot; v-focus&gt;",
  "&lt;/template&gt;",
  "",
  "&lt;script&gt;",
  "export default{",
  "directives:{",
  "// 指令在使用的时候要加上v-，但是在定义的时候只需要写v-后面的名字",
  "focus:{",
  "// el传递过来的是使用v-focus指令的DOM元素",
  "mounted(el){",
  "el.focus()",
  "}",
  "}",
  "}",
  "}",
  "&lt;/script&gt;",
  "",
  "",
  "// 全局directives  Main.js",
  "createApp().directives(&#39;focus&#39;,{",
  "mounted(el){",
  "// 同样的写法",
  "}",
  "})",
  "</code></pre>",
  "<h4>Directive - 时间戳案例</h4>",
  "<p>谈及将时间戳格式化的案例时，首当其冲想到的是vue2的filter对其进行转化，在vue3中已经取消了对filter的支持，我们比较容易想到定义一个method，传递进去参数返回一个格式化的时间戳，但是通过指令也可以实现，顺便可以实验以下指令生命周期函数中第二个参数bindings的作用</p>",
  "<pre class='language-javascript'><code class='language-vue' lang='vue'>&lt;template&gt;",
  "&lt;div v-formatTime=&quot;YYYY/MM/DD&quot;&gt;",
  "12389891398",
  "&lt;/div&gt;",
  "&lt;/template&gt;",
  "",
  "&lt;script&gt;",
  "import dayjs from &#39;dayjs&#39;",
  "export default {",
  "directives:{",
  "formatTime:{",
  "mounted(el,bindings){",
  "const textContent = el.textContent",
  "",
  "let timestamp = dayjs(parseInt(textContent)).format(&quot;YYYY-MM-DD HH:mm:ss&quot;)",
  "",
  "// 我们使用v-model等一些内置指令的时候可以往其上传递参数或者修饰符",
  "// 自定义指令读取参数和修饰符都是通过第二个参数bindings获取这些值",
  "// 这个案例中如果使用者想要使用自定义的时间戳格式的话",
  "// 我们可以约定使用者将值传递进指令，然后我们指令内部读取这个值传递给dayjs的format",
  "",
  "el.textContent = timestamp",
  "}",
  "}",
  "}",
  "}",
  "&lt;/script&gt;",
  "",
  "&lt;style&gt;",
  "",
  "&lt;/style&gt;",
  "</code></pre>",
  "<p>很明显这个时间戳格式转化指令是一个全局的指令，其他组件很可能会用到，对于这类指令我们通常会建立一个directives文件夹，里面创建一个index.js的出口文件:</p>",
  "<pre class='language-javascript'><code class='language-javascript' lang='javascript'>// index.js",
  "",
  "import { formatTime } from &#39;./timeFormat.js&#39;",
  "",
  "export function registerDirectives(app){",
  "timeFormat(app)",
  "}",
  "",
  "// timeFormat.js",
  "",
  "export function formatTime(app){",
  "// 接收到app实例后注册全局指令",
  "app.directive(&#39;formatTime&#39;,{",
  "mounted(el,bindings){",
  "const textContent = el.textContent",
  "",
  "let timestamp = dayjs(parseInt(textContent)).format(&quot;YYYY-MM-DD HH:mm:ss&quot;)",
  "",
  "el.textContent = timestamp",
  "}",
  "}",
  "}",
  "",
  "// main.js",
  "import {registerDirectives} from &#39;./directives&#39;",
  "",
  "const app = createApp()",
  "",
  "// 在此将app传入",
  "registerDirectives(app)",
  "</code></pre>",
  "<h4>plugins插件</h4>",
  "<p>插件可以为app提供的功能可以是没有限制的，这里我们简单用插件实现一个全局属性的注册，需要注意的是：</p>",
  "<ol>",
  "<li>插件可以是一个普通对象，但是这个对象必须要有一个install属性，这时因为app.use()对插件进行安装的时候调用的就是插件的install属性的函数</li>",
  "<li>install属性接收app的参数，我们可以在install函数里进行一切有关app的操作，app中保存着mixin,directive,config等等一系列属性，如果我们需要注册全局属性，我们直接设置app.config.globalProperties就可以，需要注意的是，通常为了防止全局属性和局部属性重名，在命名时通常将全局属性前加上<code>$</code>进行标注</li>",
  "",
  "</ol>",
  "<pre class='language-javascript'><code class='language-javascript' lang='javascript'>// plugin-object.js",
  "export default const obj = {",
  "install(app){",
  "app.config.globalProperties.$name = &#39;zya&#39;",
  "}",
  "}",
  "",
  "// main.js",
  "import ObjPlugin from &#39;./plugins/plugin-object.js&#39;",
  "const app = createApp()",
  "",
  "app.use(ObjPlugin)",
  "</code></pre>",
  "<h3>Vue源码解析</h3>",
  "<p>Vue的底层架构总共由三部分构成：</p>",
  "<ol>",
  "<li><p>Compiler - 对我们编写的template进行compile，SFC文件借助vue-loader(其中又需要vue-compiler-sfc)将所有的模版编译成render函数</p>",
  "</li>",
  "<li><p>Runtime - 运行时对render函数进行调用，形成Vnode，也就是浏览器DOM描述对象，一方面VNode可以支持跨平台页面渲染，不同的业务场景(SSR、原生IOS、安卓等)只需要编写vnode(js对象)转换成对应环境下的元素的renderer，然后通过<code>mount</code>函数将虚拟DOM挂载到真实的DOM节点上(将虚拟DOM转换成真实DOM可以使用document.createElement模拟实现)</p>",
  "<pre class='language-javascript'><code class='language-vue' lang='vue'>&lt;script&gt;",
  "const app = createApp()",
  "app.mount(&#39;#app&#39;)",
  "&lt;/script&gt;",
  "</code></pre>",
  "</li>",
  "<li><p>Reactivity - 当我们对模版里引用的某些响应式变量进行修改时，页面也会触发重新渲染，仅仅只会更新需要变化的部分，其余部分会被高效得复用</p>",
  "</li>",
  "",
  "</ol>",
  "<h3>Vue-router</h3>",
  "<h4>前端路由发展历程以及vue中路由的实现原理</h4>",
  "<p>路由的主要功能就是维护一组 <code>由路径到页面</code>(在SPA中是组件)的映射关系，在后端控制页面跳转的时代，后端路由维护着页面url到每一个请求的资源页面的映射关系，每一个url都是一条实际的对服务器发起的请求，服务器根据请求的路径进行对应页面的响应。后来ajax时代，前后端分离，后端主要处理接口以及数据库端的业务，前端调用jquery代码对服务器端发送请求，然后编写<code>document.createElement</code>代码在页面上进行渲染操作。再然后步入现如今的SPA时代，所有的页面其实都是挂载在同一个html页面中的app节点下，前端控制着url地址与<code>组件</code>显示的映射关系，url的变化并不会真正得传递到后端，现在前端路由的主要实现方式有两种：</p>",
  "<ol>",
  "<li>Hash mode，url主机名后跟上<code>#/</code>加上路径名称，#后面的路径并不会传递到服务器端，页面主需要监听hash的变化，获取hash的值然后在相应的区域展示对应路径应该显示的组件即可</li>",
  "<li>History mode，HTML5新加入的history api允许开发者通过history.pushState或者replaceState操作地址栏里的地址，此时如果禁用掉事件的默认行为，转而在相应的区域展示对应路径应该显示的组件便可以同样实现不与后端发生交互的纯前端控制的页面跳转</li>",
  "",
  "</ol>",
  "<h4>404</h4>",
  "<p>在注册路由的时候，如果router检测到的路径在路由中没有注册，但是我们也想对这些资源地址不对的页面有响应时，vue-router@拦截全局路径的时候不再是*，而是pathMatch(.*)</p>",
  "<pre class='language-javascript'><code class='language-javascript' lang='javascript'>// router.js",
  "const routes = [",
  "// 一般写在所有注册路由的最后，保证最后一个被匹配到",
  "{",
  "path:&#39;/pathMatch(.*)&#39;",
  "}",
  "]",
  "</code></pre>",
  "<h4>Magic comment</h4>",
  "<p>前面提到路由懒加载中，component属性可以是一个返回值为Promise的函数，这样打包出来的js文件就会进行分包，但是分包出来的文件都是chunk-[hash]的格式，不太好分辨哪一个文件打包出来的对应的是哪一个组件，这个时候如果我们在import函数内部使用魔法注释，webpack会解析这段注释，并且将注释的value写到打包出来的组件js文件中</p>",
  "<pre class='language-javascript'><code class='language-javascript' lang='javascript'>// router.js",
  "const routes = [",
  "{",
  "path:&#39;/foo&#39;,",
  "component: () =&gt; import(/*WebpackChunkname: foo*/ &#39;../views/foo.vue&#39;)",
  "}",
  "]",
  "</code></pre>",
  "<h4>composition api中使用vue-router</h4>",
  "<pre class='language-javascript'><code class='language-vue' lang='vue'>&lt;script&gt;",
  "import { useRouter , useRoute } from &#39;vue-router&#39;",
  "",
  "export default{",
  "setup(){",
  "// 这里获取到的router对象就是全局注册的router对象 : this.$router",
  "const router = useRouter()",
  "// 同理 : this.$route , 里面一般可以取一些queryString或者pathName",
  "const route = useRoute()",
  "}",
  "}",
  "&lt;/script&gt;",
  "</code></pre>",
  "<h4>动态添加路由</h4>",
  "<p>动态添加路由api和vue2中的相同，依旧为Router.addRoute，这里添加一下二级路由的注册方式</p>",
  "<pre class='language-javascript'><code class='language-javascript' lang='javascript'>// router.js",
  "import { createRouter } from &#39;vue-router&#39;",
  "",
  "const routes = [",
  "{",
  "path:&#39;/foo&#39;,",
  "component:Foo",
  "children:[",
  "{",
  "path:&#39;bar&#39;,",
  "component:Bar",
  "}",
  "]",
  "}",
  "]",
  "",
  "const router = createRouter({",
  "routes,",
  "// 这里需要选择使用hash模式还是使用history模式",
  "history: createHashHistoryAPI()",
  "})",
  "",
  "// 第一个参数为要添加的路由的上级路由，后面跟上要添加的路由",
  "router.addRoute(&#39;foo&#39;,{",
  "path:&#39;foobar&#39;,",
  "component:FooBar",
  "})",
  "",
  "",
  "</code></pre>",
  "<h4>全局路由守卫beforeEnter</h4>",
  "<p>beforeEnter中不再推荐使用回调函数中的第三个参数next了，因为vue2中调用next()经常会陷入循环或者不跳转，需要处理不跳转和跳转的情况(if里面跳转需要next()，外面依然要写next())。vue-router4中决定通过使用回调函数的返回值决定路由即将要跳转到的地方，如果返回为undefined或者干脆没有返回，则使用默认行为，即该跳转到哪就跳转到哪</p>",
  "<pre class='language-javascript'><code class='language-javascript' lang='javascript'>// router.js",
  "import { createRouter } from &#39;vue-router&#39;",
  "",
  "const routes = [",
  "{",
  "path:&#39;/foo&#39;,",
  "component:Foo",
  "children:[",
  "{",
  "path:&#39;bar&#39;,",
  "component:Bar",
  "}",
  "]",
  "}",
  "]",
  "",
  "const router = createRouter({",
  "routes,",
  "// 这里需要选择使用hash模式还是使用history模式",
  "history: createHashHistoryAPI()",
  "})",
  "",
  "// 全局路由守卫beforeEnter是一个函数，里面需要传递一个callback",
  "// 下面演示了一个简易的token验证流程",
  "router.beforeEnter((to,from,next) =&gt; {",
  "if(!localStorage.getItem(&#39;token&#39;)){",
  "return &#39;login&#39;",
  "}",
  "})",
  "</code></pre>",
  "<h4>historyApiFallback</h4>",
  "<p>传统的后端路由中每一个Url路径都对应着服务器端相应路径的html页面资源，如果在nginx中没有进行",
  "配置，每次对前端页面进行刷新的时候都会向对应路径去请求，正常情况下都是请求部到资源并且返回",
  "404 cant GET ./somepathname，vue脚手架默认已经将对开发时的热更新功能进行了配置，开启了这个配置后，没有",
  "匹配资源时默认就会返回根目录下的index.html，这时候再带上原有url中的pathname，就可以正常请求了</p>",
  "<p>除了修改源码更改vue-cli中的webpack配置，更优的实践是在根目录下配置vue.config.js文件",
  "configureWebpack对象下的配置最终会和webpack中的配置进行合并</p>",
  "<pre class='language-javascript'><code class='language-javascript' lang='javascript'>// vue.config.js",
  "module.exports = {",
  "configureWebpack:{",
  "devServer:{",
  "historyApiFallback:true",
  "}",
  "}",
  "}",
  "</code></pre>",
  "<p>&nbsp;</p>",
  "<h3>Vuex</h3>",
  "<p>vuex相较于老版本变化的地方并不太多，目前只看到了提供Setup中使用store的函数</p>",
  "<h4>CompositionApi 中使用store</h4>",
  "<pre class='language-javascript'><code class='language-vue' lang='vue'>&lt;script&gt;",
  "import { useStore } from &#39;vuex&#39;",
  "export default{",
  "setup(){",
  "const store = useStore()",
  "let foo = store.state.foo",
  "return {",
  "foo",
  "}",
  "}",
  "}",
  "&lt;/script&gt;",
  "</code></pre>",
  "<h4>mapState</h4>",
  "<p>如果我们需要组件中使用全局store中的state，在模板中我们的开发代码可能如下:</p>",
  "<pre class='language-javascript'><code class='language-vue' lang='vue'>&lt;template&gt;",
  "&lt;div&gt;",
  "{{$store.state.foo}}",
  "&lt;/div&gt;",
  "&lt;/template&gt;",
  "</code></pre>",
  "<p>模板中尽量还是不要放这种代码，所以我们可能会想要把他抽离到computed选项中：</p>",
  "<pre class='language-javascript'><code class='language-vue' lang='vue'>&lt;script&gt;",
  "export default{",
  "computed:{",
  "foo(){",
  "return this.$store.state.foo",
  "}",
  "}",
  "}",
  "&lt;/script&gt;",
  "</code></pre>",
  "<p>可是当这种需要抽离成computed的全局属性多了，我们一个一个编写会比较繁琐，所以我们可以借助vuex中提供的工具函数mapState:</p>",
  "<pre class='language-javascript'><code class='language-vue' lang='vue'>&lt;script&gt;",
  "import { mapState } from &#39;vuex&#39;",
  "export default{",
  "computed:{",
  "// mapState函数返回一个对象，对象里面的key,value就是computed中的形式，一个key对应一个getter函数",
  "...mapState([&quot;foo&quot;,&quot;bar&quot;,&quot;foobar&quot;])",
  "// 相当于",
  "/*",
  "foo(){",
  "return this.$store.state.foo",
  "},",
  "bar(){",
  "return this.$store.state.foo",
  "},",
  "foobar(){",
  "return this.$store.state.foo",
  "}",
  "*/",
  "// 一般情况下mapState中传数组的情况比较多，同时也支持取别名的对象参数传参",
  "// 如下代码在调用的时候直接取fooAlias，就相当于在取foo",
  "...mapState(",
  "{",
  "fooAlias: state =&gt; state.foo",
  "}",
  ")",
  "}",
  "}",
  "&lt;/script&gt;",
  "</code></pre>",
  "<h4>modules</h4>",
  "<p>所有的全局属性都放在一个单一状态树种管理带来的不方便就是如果所有的全局属性都写在rootState中，后续store.js中的代码就会特别庞大和臃肿，vuex允许我们在store中使用modules将每一个不同模块中需要的数据放在不同的module文件中管理:</p>",
  "<pre class='language-javascript'><code class='language-javascript' lang='javascript'>// store.js",
  "import { createStore } from &#39;vuex&#39;",
  "import home from &#39;./modules/home.js&#39;",
  "",
  "const store = createStore({",
  "state:{},",
  "mutations:{",
  "incremnt(){",
  "console.log(&#39;im rootMutations&#39;)",
  "}",
  "},",
  "actions:{},",
  "getters:{},",
  "// 这里modules是一个对象，key值代表注册的模块名称，value值就是对应模块导出的js文件，每个js模块文件里同时又可以设置模块内部       \t // 的state,mutations,actions..",
  "modules:{}",
  "})",
  "",
  "// home.js",
  "export default {",
  "state:{",
  "homeCounter:1",
  "},",
  "mutations:{",
  "increment(state){",
  "state.homeCounter++",
  "}",
  "},",
  "actions:{",
  "incrementAction(ctx){",
  "ctx.commit(&#39;increment&#39;)",
  "}",
  "}",
  "}",
  "</code></pre>",
  "<p>于此同时在需要使用vuex中全局状态的组件文件中：</p>",
  "<pre class='language-javascript'><code class='language-vue' lang='vue'>&lt;template&gt;",
  "&lt;div&gt;",
  "{{$store.state.home.homeCounter}}",
  "&lt;/div&gt;",
  "&lt;/template&gt;",
  "</code></pre>",
  "<p>请注意上方home.js中的mutations有与root中同名的increment方法，这会导致如果在一个组件中commit同名的mutation，无论子模块还是root中的mutation都会调用，原因就是如果子模块没有开启namespaced命名空间，vuex默认会对这些mutations以及getters还有actions做合并处理，在开发中这样的代码不容易看出到底调的是子模块的方法还是Root中的方法，所以我们可以开启模块文件的namespaced，但是commit,dispatch还有getters的写法也要做出相应的调整:</p>",
  "<p>开启命名空间后的getters,mutation以及action就不能通过往常的方式进行访问了</p>",
  "<pre class='language-javascript'><code class='language-vue' lang='vue'>&lt;template&gt;",
  "// 错误的访问方式",
  "{{$store.getters.home.newTest}}",
  "// 同样不行",
  "{{$store.getters.newTest}}",
  "",
  "// 经历过mapGetters后，直接访问newTest",
  "{{newTest}}",
  "&lt;/template&gt;",
  "",
  "&lt;script&gt;",
  "export default{",
  "computed:{",
  "// 第一个参数传对应数据所在的模块名称，后面传映射数组",
  "...mapGetters(&#39;home&#39;,[&#39;newTest&#39;])",
  "},",
  "methods:{",
  "handleClick(){",
  "// 同时commit的写法也需要改变",
  "this.$store.commit(&#39;home/changetest&#39;)",
  "},",
  "...mapMutations(&quot;home&quot;,[&quot;changetest&quot;])",
  "}",
  "}",
  "&lt;/script&gt;",
  "</code></pre>",
  "<h3>TS环境搭建</h3>",
  "<p>首先创建项目文件夹，根目录下创建src文件夹，使用npm init -y生成packjson.json 包管理文件",
  "我们需要使用webpack来开启一个具有热更新功能的开发环境，npm install webpack webpack-cli -D",
  "在package.json文件的script属性中添加开启webpack-dev-server的脚本(wepack serve)，此处",
  "需要下载webpack-dev-server，编写webpack.config.js配置文件,解析typescript需要下载ts-loader,",
  "ts-loader同时引用了typescript</p>",
  "<p>ts文件使用es6模块引入方式引入不允许以.ts为后缀名，例如import {sum} from &#39;./math.ts&#39; 不被允许，",
  "需要写成 import {sum} from &#39;./math&#39; 而又因为webpack的默认配置中文件引入方式只有.js 和 .json",
  "结尾的文件，所以我们需要在resolve的extensions属性里面添加上&#39;.ts&#39;后缀名</p>",
  "<p>ts-loader编译需要根目录下有tsconfig.json这个文件，",
  "需要通过tsc --init方式创建开启默认配置的typescript</p>",
  "<h2>Vue3后台管理系统</h2>",
  "<h3>项目搭建及配置</h3>",
  "<p>项目默认使用vue-cli官方脚手架进行搭建，使用less作为css预处理器，使用eslint+prettier进行代码风格管理</p>",
  "<h3>.editorconfig</h3>",
  "<p>默认情况下同一个项目可能有不同的人员接手，代码风格的统一例如缩进、一条语句结束是否空行都可以通过配置.editorconfig来对代码编辑器进行配置，vscode如果需要读取editorconfig需要额外进行一个插件的下载(editorconfig for vscode)</p>",
  "<h3>Prettier</h3>",
  "<p>VS code的插件列表中可以下载prettier，默认情况下是没有 文件保存时lint的功能的，且多数情况下需要将prettier设置成默认的javascript lintter才可以生效。</p>",
  "<p>在VS code 的settings.json中，设置如下json即可</p>",
  "<pre class='language-javascript'><code class='language-javascript' lang='javascript'>{",
  "&quot;editor.formatOnSave&quot;: true,",
  "&quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;,",
  "}",
  "</code></pre>",
  "<p>同样，prettier也提供npm包的下载方式，在开发时依赖中添加prettier后，可以在package.json中设置手动Lint项目代码的指令：</p>",
  "<pre class='language-javascript'><code class='language-javascript' lang='javascript'>&quot;scripts&quot;:{",
  "&quot;lint&quot;:&quot;prettier --write .&quot;",
  "}",
  "</code></pre>",
  "<p>这种情况下prettier会默认去寻找项目根目录下的.prettierrc文件读取prettier的参数配置，同时我们可以设置.prettierignore文件来指定哪些文件不需要格式化。</p>",
  "<h3>Husky</h3>",
  "<p>husky提供我们在git提交过程中的流程控制，里面比较有用的hook有：pre-commit/ commit-message 以及 pre-push，pre-commit钩子中可以运行prettier或者eslint脚本对项目进行格式化修复以防止不规范的代码上传到代码仓库中，commit-message钩子中可以运行commitlint工具(需要配置)对commit message进行校验。</p>",
  "<p>commit message中可以使用commitizen进行提交进而取代传统的<code>git commit -m &#39;foo&#39;</code>的提交形式，安装并配置好commitizen在项目中后可以使用指令<code>npx cz</code>唤出commitizen的cli面板，里面提供了规范的提交格式提醒。</p>",
  "<p>npx指令默认回去找寻node_modules下的.bin中的可以执行的指令。</p>",
  ""
],
    "type": "学习笔记",
    "title": "Vue3学习笔记",
    "date": 2020
  }
]
